var searchIndex = {};
searchIndex['nix'] = {"items":[[0,"","nix","Rust friendly bindings to the various *nix system functions."],[6,"c_int","",""],[4,"c_void","","Type used to construct void pointers for use with C."],[13,"__variant1","","",0],[13,"__variant2","","",0],[4,"NixError","",""],[13,"Sys","","",1],[13,"InvalidPath","","",1],[5,"from_ffi","",""],[11,"eq","","",1],[11,"ne","","",1],[11,"fmt","","",1],[11,"clone","","",1],[11,"last","","",1],[11,"invalid_argument","","",1],[11,"with_nix_path","std::path","",2],[11,"with_nix_path","","",3],[0,"errno","nix",""],[4,"Errno","nix::errno",""],[13,"UnknownErrno","","",4],[13,"EPERM","","",4],[13,"ENOENT","","",4],[13,"ESRCH","","",4],[13,"EINTR","","",4],[13,"EIO","","",4],[13,"ENXIO","","",4],[13,"E2BIG","","",4],[13,"ENOEXEC","","",4],[13,"EBADF","","",4],[13,"ECHILD","","",4],[13,"EAGAIN","","",4],[13,"ENOMEM","","",4],[13,"EACCES","","",4],[13,"EFAULT","","",4],[13,"ENOTBLK","","",4],[13,"EBUSY","","",4],[13,"EEXIST","","",4],[13,"EXDEV","","",4],[13,"ENODEV","","",4],[13,"ENOTDIR","","",4],[13,"EISDIR","","",4],[13,"EINVAL","","",4],[13,"ENFILE","","",4],[13,"EMFILE","","",4],[13,"ENOTTY","","",4],[13,"ETXTBSY","","",4],[13,"EFBIG","","",4],[13,"ENOSPC","","",4],[13,"ESPIPE","","",4],[13,"EROFS","","",4],[13,"EMLINK","","",4],[13,"EPIPE","","",4],[13,"EDOM","","",4],[13,"ERANGE","","",4],[13,"EDEADLK","","",4],[13,"ENAMETOOLONG","","",4],[13,"ENOLCK","","",4],[13,"ENOSYS","","",4],[13,"ENOTEMPTY","","",4],[13,"ELOOP","","",4],[13,"ENOMSG","","",4],[13,"EIDRM","","",4],[13,"ECHRNG","","",4],[13,"EL2NSYNC","","",4],[13,"EL3HLT","","",4],[13,"EL3RST","","",4],[13,"ELNRNG","","",4],[13,"EUNATCH","","",4],[13,"ENOCSI","","",4],[13,"EL2HLT","","",4],[13,"EBADE","","",4],[13,"EBADR","","",4],[13,"EXFULL","","",4],[13,"ENOANO","","",4],[13,"EBADRQC","","",4],[13,"EBADSLT","","",4],[13,"EBFONT","","",4],[13,"ENOSTR","","",4],[13,"ENODATA","","",4],[13,"ETIME","","",4],[13,"ENOSR","","",4],[13,"ENONET","","",4],[13,"ENOPKG","","",4],[13,"EREMOTE","","",4],[13,"ENOLINK","","",4],[13,"EADV","","",4],[13,"ESRMNT","","",4],[13,"ECOMM","","",4],[13,"EPROTO","","",4],[13,"EMULTIHOP","","",4],[13,"EDOTDOT","","",4],[13,"EBADMSG","","",4],[13,"EOVERFLOW","","",4],[13,"ENOTUNIQ","","",4],[13,"EBADFD","","",4],[13,"EREMCHG","","",4],[13,"ELIBACC","","",4],[13,"ELIBBAD","","",4],[13,"ELIBSCN","","",4],[13,"ELIBMAX","","",4],[13,"ELIBEXEC","","",4],[13,"EILSEQ","","",4],[13,"ERESTART","","",4],[13,"ESTRPIPE","","",4],[13,"EUSERS","","",4],[13,"ENOTSOCK","","",4],[13,"EDESTADDRREQ","","",4],[13,"EMSGSIZE","","",4],[13,"EPROTOTYPE","","",4],[13,"ENOPROTOOPT","","",4],[13,"EPROTONOSUPPORT","","",4],[13,"ESOCKTNOSUPPORT","","",4],[13,"EOPNOTSUPP","","",4],[13,"EPFNOSUPPORT","","",4],[13,"EAFNOSUPPORT","","",4],[13,"EADDRINUSE","","",4],[13,"EADDRNOTAVAIL","","",4],[13,"ENETDOWN","","",4],[13,"ENETUNREACH","","",4],[13,"ENETRESET","","",4],[13,"ECONNABORTED","","",4],[13,"ECONNRESET","","",4],[13,"ENOBUFS","","",4],[13,"EISCONN","","",4],[13,"ENOTCONN","","",4],[13,"ESHUTDOWN","","",4],[13,"ETOOMANYREFS","","",4],[13,"ETIMEDOUT","","",4],[13,"ECONNREFUSED","","",4],[13,"EHOSTDOWN","","",4],[13,"EHOSTUNREACH","","",4],[13,"EALREADY","","",4],[13,"EINPROGRESS","","",4],[13,"ESTALE","","",4],[13,"EUCLEAN","","",4],[13,"ENOTNAM","","",4],[13,"ENAVAIL","","",4],[13,"EISNAM","","",4],[13,"EREMOTEIO","","",4],[13,"EDQUOT","","",4],[13,"ENOMEDIUM","","",4],[13,"EMEDIUMTYPE","","",4],[13,"ECANCELED","","",4],[13,"ENOKEY","","",4],[13,"EKEYEXPIRED","","",4],[13,"EKEYREVOKED","","",4],[13,"EKEYREJECTED","","",4],[13,"EOWNERDEAD","","",4],[13,"ENOTRECOVERABLE","","",4],[13,"ERFKILL","","",4],[13,"EHWPOISON","","",4],[11,"from_i64","","",4],[11,"from_u64","","",4],[11,"eq","","",4],[11,"ne","","",4],[11,"clone","","",4],[11,"fmt","","",4],[11,"last","","",4],[11,"desc","","",4],[17,"EWOULDBLOCK","",""],[17,"EDEADLOCK","",""],[11,"from_i64","","",4],[11,"from_u64","","",4],[11,"eq","","",4],[11,"ne","","",4],[11,"clone","","",4],[11,"fmt","","",4],[11,"last","","",4],[11,"desc","","",4],[0,"features","nix",""],[5,"socket_atomic_cloexec","nix::features",""],[0,"fcntl","nix",""],[3,"OFlag","nix::fcntl",""],[3,"FdFlag","",""],[3,"flock","",""],[12,"l_type","","",5],[12,"l_whence","","",5],[12,"l_start","","",5],[12,"l_len","","",5],[12,"l_pid","","",5],[12,"l_sysid","","",5],[4,"FcntlArg","",""],[13,"F_DUPFD","","",6],[13,"F_DUPFD_CLOEXEC","","",6],[13,"F_GETFD","","",6],[13,"F_SETFD","","",6],[13,"F_GETFL","","",6],[13,"F_SETFL","","",6],[13,"F_SETLK","","",6],[13,"F_SETLKW","","",6],[13,"F_GETLK","","",6],[13,"F_OFD_SETLK","","",6],[13,"F_OFD_SETLKW","","",6],[13,"F_OFD_GETLK","","",6],[5,"open","",""],[5,"fcntl","",""],[11,"hash","","",7],[11,"cmp","","",7],[11,"partial_cmp","","",7],[11,"lt","","",7],[11,"le","","",7],[11,"gt","","",7],[11,"ge","","",7],[11,"clone","","",7],[11,"eq","","",7],[11,"ne","","",7],[11,"empty","","Returns an empty set of flags.",7],[11,"all","","Returns the set containing all flags.",7],[11,"bits","","Returns the raw value of the flags currently stored.",7],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",7],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",7],[11,"is_empty","","Returns `true` if no flags are currently stored.",7],[11,"is_all","","Returns `true` if all flags are currently set.",7],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",7],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",7],[11,"insert","","Inserts the specified flags in-place.",7],[11,"remove","","Removes the specified flags in-place.",7],[11,"toggle","","Toggles the specified flags in-place.",7],[11,"bitor","","Returns the union of the two sets of flags.",7],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",7],[11,"bitand","","Returns the intersection between the two sets of flags.",7],[11,"sub","","Returns the set difference of the two sets of flags.",7],[11,"not","","Returns the complement of this set of flags.",7],[11,"hash","","",8],[11,"cmp","","",8],[11,"partial_cmp","","",8],[11,"lt","","",8],[11,"le","","",8],[11,"gt","","",8],[11,"ge","","",8],[11,"clone","","",8],[11,"eq","","",8],[11,"ne","","",8],[11,"empty","","Returns an empty set of flags.",8],[11,"all","","Returns the set containing all flags.",8],[11,"bits","","Returns the raw value of the flags currently stored.",8],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",8],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",8],[11,"is_empty","","Returns `true` if no flags are currently stored.",8],[11,"is_all","","Returns `true` if all flags are currently set.",8],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",8],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",8],[11,"insert","","Inserts the specified flags in-place.",8],[11,"remove","","Removes the specified flags in-place.",8],[11,"toggle","","Toggles the specified flags in-place.",8],[11,"bitor","","Returns the union of the two sets of flags.",8],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",8],[11,"bitand","","Returns the intersection between the two sets of flags.",8],[11,"sub","","Returns the set difference of the two sets of flags.",8],[11,"not","","Returns the complement of this set of flags.",8],[6,"Fd","",""],[17,"O_ACCMODE","",""],[17,"O_RDONLY","",""],[17,"O_WRONLY","",""],[17,"O_RDWR","",""],[17,"O_CREAT","",""],[17,"O_EXCL","",""],[17,"O_NOCTTY","",""],[17,"O_TRUNC","",""],[17,"O_APPEND","",""],[17,"O_NONBLOCK","",""],[17,"O_DSYNC","",""],[17,"O_DIRECT","",""],[17,"O_LARGEFILE","",""],[17,"O_DIRECTORY","",""],[17,"O_NOFOLLOW","",""],[17,"O_NOATIME","",""],[17,"O_CLOEXEC","",""],[17,"O_SYNC","",""],[17,"O_PATH","",""],[17,"O_TMPFILE","",""],[17,"O_NDELAY","",""],[17,"FD_CLOEXEC","",""],[11,"hash","","",7],[11,"cmp","","",7],[11,"partial_cmp","","",7],[11,"lt","","",7],[11,"le","","",7],[11,"gt","","",7],[11,"ge","","",7],[11,"clone","","",7],[11,"eq","","",7],[11,"ne","","",7],[11,"empty","","Returns an empty set of flags.",7],[11,"all","","Returns the set containing all flags.",7],[11,"bits","","Returns the raw value of the flags currently stored.",7],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",7],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",7],[11,"is_empty","","Returns `true` if no flags are currently stored.",7],[11,"is_all","","Returns `true` if all flags are currently set.",7],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",7],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",7],[11,"insert","","Inserts the specified flags in-place.",7],[11,"remove","","Removes the specified flags in-place.",7],[11,"toggle","","Toggles the specified flags in-place.",7],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",7],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",7],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",7],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",7],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",7],[11,"hash","","",8],[11,"cmp","","",8],[11,"partial_cmp","","",8],[11,"lt","","",8],[11,"le","","",8],[11,"gt","","",8],[11,"ge","","",8],[11,"clone","","",8],[11,"eq","","",8],[11,"ne","","",8],[11,"empty","","Returns an empty set of flags.",8],[11,"all","","Returns the set containing all flags.",8],[11,"bits","","Returns the raw value of the flags currently stored.",8],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",8],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",8],[11,"is_empty","","Returns `true` if no flags are currently stored.",8],[11,"is_all","","Returns `true` if all flags are currently set.",8],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",8],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",8],[11,"insert","","Inserts the specified flags in-place.",8],[11,"remove","","Removes the specified flags in-place.",8],[11,"toggle","","Toggles the specified flags in-place.",8],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",8],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",8],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",8],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",8],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",8],[0,"mount","nix",""],[3,"MsFlags","nix::mount",""],[3,"MntFlags","",""],[5,"umount","",""],[5,"umount2","",""],[17,"MS_RDONLY","",""],[17,"MS_NOSUID","",""],[17,"MS_NODEV","",""],[17,"MS_NOEXEC","",""],[17,"MS_SYNCHRONOUS","",""],[17,"MS_REMOUNT","",""],[17,"MS_MANDLOCK","",""],[17,"MS_DIRSYNC","",""],[17,"MS_NOATIME","",""],[17,"MS_NODIRATIME","",""],[17,"MS_BIND","",""],[17,"MS_MOVE","",""],[17,"MS_REC","",""],[17,"MS_VERBOSE","",""],[17,"MS_SILENT","",""],[17,"MS_POSIXACL","",""],[17,"MS_UNBINDABLE","",""],[17,"MS_PRIVATE","",""],[17,"MS_SLAVE","",""],[17,"MS_SHARED","",""],[17,"MS_RELATIME","",""],[17,"MS_KERNMOUNT","",""],[17,"MS_I_VERSION","",""],[17,"MS_STRICTATIME","",""],[17,"MS_NOSEC","",""],[17,"MS_BORN","",""],[17,"MS_ACTIVE","",""],[17,"MS_NOUSER","",""],[17,"MS_RMT_MASK","",""],[17,"MS_MGC_VAL","",""],[17,"MS_MGC_MSK","",""],[17,"MNT_FORCE","",""],[17,"MNT_DETATCH","",""],[17,"MNT_EXPIRE","",""],[11,"hash","","",9],[11,"cmp","","",9],[11,"partial_cmp","","",9],[11,"lt","","",9],[11,"le","","",9],[11,"gt","","",9],[11,"ge","","",9],[11,"clone","","",9],[11,"eq","","",9],[11,"ne","","",9],[11,"empty","","Returns an empty set of flags.",9],[11,"all","","Returns the set containing all flags.",9],[11,"bits","","Returns the raw value of the flags currently stored.",9],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",9],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",9],[11,"is_empty","","Returns `true` if no flags are currently stored.",9],[11,"is_all","","Returns `true` if all flags are currently set.",9],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",9],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",9],[11,"insert","","Inserts the specified flags in-place.",9],[11,"remove","","Removes the specified flags in-place.",9],[11,"toggle","","Toggles the specified flags in-place.",9],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",9],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",9],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",9],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",9],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",9],[11,"hash","","",10],[11,"cmp","","",10],[11,"partial_cmp","","",10],[11,"lt","","",10],[11,"le","","",10],[11,"gt","","",10],[11,"ge","","",10],[11,"clone","","",10],[11,"eq","","",10],[11,"ne","","",10],[11,"empty","","Returns an empty set of flags.",10],[11,"all","","Returns the set containing all flags.",10],[11,"bits","","Returns the raw value of the flags currently stored.",10],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",10],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",10],[11,"is_empty","","Returns `true` if no flags are currently stored.",10],[11,"is_all","","Returns `true` if all flags are currently set.",10],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",10],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",10],[11,"insert","","Inserts the specified flags in-place.",10],[11,"remove","","Removes the specified flags in-place.",10],[11,"toggle","","Toggles the specified flags in-place.",10],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",10],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",10],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",10],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",10],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",10],[0,"sched","nix",""],[3,"CpuSet","nix::sched",""],[5,"sched_setaffinity","",""],[5,"clone","",""],[5,"unshare","",""],[6,"CloneFlags","",""],[6,"CloneCb","",""],[6,"CpuMask","",""],[7,"CLONE_VM","",""],[7,"CLONE_FS","",""],[7,"CLONE_FILES","",""],[7,"CLONE_SIGHAND","",""],[7,"CLONE_PTRACE","",""],[7,"CLONE_VFORK","",""],[7,"CLONE_PARENT","",""],[7,"CLONE_THREAD","",""],[7,"CLONE_NEWNS","",""],[7,"CLONE_SYSVSEM","",""],[7,"CLONE_SETTLS","",""],[7,"CLONE_PARENT_SETTID","",""],[7,"CLONE_CHILD_CLEARTID","",""],[7,"CLONE_DETACHED","",""],[7,"CLONE_UNTRACED","",""],[7,"CLONE_CHILD_SETTID","",""],[7,"CLONE_NEWUTS","",""],[7,"CLONE_NEWIPC","",""],[7,"CLONE_NEWUSER","",""],[7,"CLONE_NEWPID","",""],[7,"CLONE_NEWNET","",""],[7,"CLONE_IO","",""],[11,"new","","",11],[11,"set","","",11],[11,"unset","","",11],[0,"sys","nix",""],[0,"epoll","nix::sys",""],[3,"EpollEventKind","nix::sys::epoll",""],[3,"EpollEvent","",""],[12,"events","","",12],[12,"data","","",12],[4,"EpollOp","",""],[13,"EpollCtlAdd","","",13],[13,"EpollCtlDel","","",13],[13,"EpollCtlMod","","",13],[5,"epoll_create","",""],[5,"epoll_ctl","",""],[5,"epoll_wait","",""],[17,"EPOLLIN","",""],[17,"EPOLLPRI","",""],[17,"EPOLLOUT","",""],[17,"EPOLLRDNORM","",""],[17,"EPOLLRDBAND","",""],[17,"EPOLLWRNORM","",""],[17,"EPOLLWRBAND","",""],[17,"EPOLLMSG","",""],[17,"EPOLLERR","",""],[17,"EPOLLHUP","",""],[17,"EPOLLRDHUP","",""],[17,"EPOLLWAKEUP","",""],[17,"EPOLLONESHOT","",""],[17,"EPOLLET","",""],[11,"hash","","",14],[11,"cmp","","",14],[11,"partial_cmp","","",14],[11,"lt","","",14],[11,"le","","",14],[11,"gt","","",14],[11,"ge","","",14],[11,"clone","","",14],[11,"eq","","",14],[11,"ne","","",14],[11,"empty","","Returns an empty set of flags.",14],[11,"all","","Returns the set containing all flags.",14],[11,"bits","","Returns the raw value of the flags currently stored.",14],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",14],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",14],[11,"is_empty","","Returns `true` if no flags are currently stored.",14],[11,"is_all","","Returns `true` if all flags are currently set.",14],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",14],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",14],[11,"insert","","Inserts the specified flags in-place.",14],[11,"remove","","Removes the specified flags in-place.",14],[11,"toggle","","Toggles the specified flags in-place.",14],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",14],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",14],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",14],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",14],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",14],[11,"fmt","","",14],[0,"eventfd","nix::sys",""],[3,"EventFdFlag","nix::sys::eventfd",""],[5,"eventfd","",""],[17,"EFD_CLOEXEC","",""],[17,"EFD_NONBLOCK","",""],[17,"EFD_SEMAPHORE","",""],[11,"hash","","",15],[11,"cmp","","",15],[11,"partial_cmp","","",15],[11,"lt","","",15],[11,"le","","",15],[11,"gt","","",15],[11,"ge","","",15],[11,"clone","","",15],[11,"eq","","",15],[11,"ne","","",15],[11,"empty","","Returns an empty set of flags.",15],[11,"all","","Returns the set containing all flags.",15],[11,"bits","","Returns the raw value of the flags currently stored.",15],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",15],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",15],[11,"is_empty","","Returns `true` if no flags are currently stored.",15],[11,"is_all","","Returns `true` if all flags are currently set.",15],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",15],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",15],[11,"insert","","Inserts the specified flags in-place.",15],[11,"remove","","Removes the specified flags in-place.",15],[11,"toggle","","Toggles the specified flags in-place.",15],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",15],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",15],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",15],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",15],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",15],[0,"ioctl","nix::sys",""],[3,"Winsize","nix::sys::ioctl",""],[12,"ws_row","","",16],[12,"ws_col","","",16],[12,"ws_xpixel","","",16],[12,"ws_ypixel","","",16],[4,"IoctlArg","",""],[13,"TIOCGWINSZ","","",17],[5,"ioctl","",""],[11,"fmt","","",16],[0,"signal","nix::sys",""],[17,"SIGHUP","nix::sys::signal",""],[17,"SIGINT","",""],[17,"SIGQUIT","",""],[17,"SIGILL","",""],[17,"SIGABRT","",""],[17,"SIGFPE","",""],[17,"SIGKILL","",""],[17,"SIGSEGV","",""],[17,"SIGPIPE","",""],[17,"SIGALRM","",""],[17,"SIGTERM","",""],[3,"SigSet","",""],[3,"SigAction","",""],[5,"sigaction","",""],[5,"kill","",""],[0,"signal","",""],[3,"SockFlag","nix::sys::signal::signal",""],[3,"siginfo","",""],[12,"pid","","",18],[12,"uid","","",18],[12,"status","","",18],[3,"sigaction","",""],[12,"sa_handler","","",19],[12,"sa_mask","","",19],[12,"sa_flags","","",19],[3,"sigset_t","",""],[17,"SA_NOCLDSTOP","",""],[17,"SA_NOCLDWAIT","",""],[17,"SA_NODEFER","",""],[17,"SA_ONSTACK","",""],[17,"SA_RESETHAND","",""],[17,"SA_RESTART","",""],[17,"SA_SIGINFO","",""],[17,"SIGTRAP","",""],[17,"SIGIOT","",""],[17,"SIGBUS","",""],[17,"SIGUSR1","",""],[17,"SIGUSR2","",""],[17,"SIGSTKFLT","",""],[17,"SIGCHLD","",""],[17,"SIGCONT","",""],[17,"SIGSTOP","",""],[17,"SIGTSTP","",""],[17,"SIGTTIN","",""],[17,"SIGTTOU","",""],[17,"SIGURG","",""],[17,"SIGXCPU","",""],[17,"SIGXFSZ","",""],[17,"SIGVTALRM","",""],[17,"SIGPROF","",""],[17,"SIGWINCH","",""],[17,"SIGIO","",""],[17,"SIGPOLL","",""],[17,"SIGPWR","",""],[17,"SIGSYS","",""],[17,"SIGUNUSED","",""],[11,"hash","","",20],[11,"cmp","","",20],[11,"partial_cmp","","",20],[11,"lt","","",20],[11,"le","","",20],[11,"gt","","",20],[11,"ge","","",20],[11,"clone","","",20],[11,"eq","","",20],[11,"ne","","",20],[11,"empty","","Returns an empty set of flags.",20],[11,"all","","Returns the set containing all flags.",20],[11,"bits","","Returns the raw value of the flags currently stored.",20],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",20],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",20],[11,"is_empty","","Returns `true` if no flags are currently stored.",20],[11,"is_all","","Returns `true` if all flags are currently set.",20],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",20],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",20],[11,"insert","","Inserts the specified flags in-place.",20],[11,"remove","","Removes the specified flags in-place.",20],[11,"toggle","","Toggles the specified flags in-place.",20],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",20],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",20],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",20],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",20],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",20],[6,"SigNum","nix::sys::signal",""],[17,"SIGEMT","",""],[11,"empty","","",21],[11,"add","","",21],[11,"remove","","",21],[11,"new","","",22],[0,"socket","nix::sys","Socket interface functions"],[3,"in_addr","nix::sys::socket",""],[12,"s_addr","","",23],[3,"in6_addr","",""],[12,"s6_addr","","",24],[3,"sockaddr","",""],[12,"sa_family","","",25],[12,"sa_data","","",25],[3,"sockaddr_storage","",""],[12,"ss_family","","",26],[12,"__ss_align","","",26],[12,"__ss_pad2","","",26],[3,"sockaddr_in","",""],[12,"sin_family","","",27],[12,"sin_port","","",27],[12,"sin_addr","","",27],[12,"sin_zero","","",27],[3,"sockaddr_in6","",""],[12,"sin6_family","","",28],[12,"sin6_port","","",28],[12,"sin6_flowinfo","","",28],[12,"sin6_addr","","",28],[12,"sin6_scope_id","","",28],[3,"sockaddr_un","",""],[12,"sun_family","","",29],[12,"sun_path","","",29],[6,"sa_family_t","",""],[3,"UnixAddr","",""],[3,"Ipv4Addr","",""],[3,"Ipv6Addr","",""],[3,"ip_mreq","",""],[12,"imr_multiaddr","","",30],[12,"imr_interface","","",30],[3,"SockFlag","",""],[3,"linger","",""],[12,"l_onoff","","",31],[12,"l_linger","","",31],[4,"AddressFamily","",""],[13,"Unix","","",32],[13,"Inet","","",32],[13,"Inet6","","",32],[4,"SockAddr","","Represents a socket address"],[13,"Inet","","",33],[13,"Unix","","",33],[4,"InetAddr","",""],[13,"V4","","",34],[13,"V6","","",34],[4,"IpAddr","",""],[13,"V4","","",35],[13,"V6","","",35],[4,"SockType","",""],[13,"Stream","","",36],[13,"Datagram","","",36],[13,"SeqPacket","","",36],[13,"Raw","","",36],[13,"Rdm","","",36],[4,"SockLevel","","The protocol level at which to get / set socket options. Used as an\nargument to `getsockopt` and `setsockopt`."],[13,"Socket","","",37],[13,"Tcp","","",37],[13,"Ip","","",37],[13,"Ipv6","","",37],[13,"Udp","","",37],[5,"socket","","Create an endpoint for communication"],[5,"listen","","Listen for connections on a socket"],[5,"bind","","Bind a name to a socket"],[5,"accept","","Accept a connection on a socket"],[5,"accept4","","Accept a connection on a socket"],[5,"connect","","Initiate a connection on a socket"],[5,"recvfrom","","Receive data from a connectionless or connection-oriented socket. Returns\nthe number of bytes read and the socket address of the sender."],[5,"sendto","",""],[5,"getsockopt","","Get the current value for the requested socket option"],[5,"setsockopt","","Sets the value for the requested socket option"],[5,"getpeername","","Get the address of the peer connected to the socket `fd`."],[5,"getsockname","","Get the current address to which the socket `fd` is bound."],[11,"hash","","",32],[11,"fmt","","",32],[11,"eq","","",32],[11,"ne","","",32],[11,"clone","","",32],[11,"from_std","","",34],[11,"new","","",34],[11,"ip","","Gets the IP address associated with this socket address.",34],[11,"port","","Gets the port number associated with this socket address",34],[11,"to_std","","",34],[11,"to_str","","",34],[11,"eq","","",34],[11,"hash","","",34],[11,"clone","","",34],[11,"fmt","","",34],[11,"new_v4","","Create a new IpAddr that contains an IPv4 address.",35],[11,"new_v6","","Create a new IpAddr that contains an IPv6 address.",35],[11,"from_std","","",35],[11,"to_std","","",35],[11,"fmt","","",35],[11,"new","","",38],[11,"from_std","","",38],[11,"any","","",38],[11,"octets","","",38],[11,"to_std","","",38],[11,"eq","","",38],[11,"hash","","",38],[11,"clone","","",38],[11,"fmt","","",38],[11,"new","","",39],[11,"from_std","","",39],[11,"segments","","Return the eight 16-bit segments that make up this address",39],[11,"to_std","","",39],[11,"fmt","","",39],[11,"new","","",40],[11,"path","","",40],[11,"eq","","",40],[11,"hash","","",40],[11,"clone","","",40],[11,"fmt","","",40],[11,"new_inet","","",33],[11,"new_unix","","",33],[11,"family","","",33],[11,"to_str","","",33],[11,"as_ffi_pair","","",33],[11,"eq","","",33],[11,"hash","","",33],[11,"clone","","",33],[11,"fmt","","",33],[11,"fmt","","",30],[11,"new","","",30],[0,"sockopt","",""],[3,"ReuseAddr","nix::sys::socket::sockopt",""],[3,"ReusePort","",""],[3,"TcpNoDelay","",""],[3,"Linger","",""],[3,"IpAddMembership","",""],[3,"IpDropMembership","",""],[3,"IpMulticastTtl","",""],[3,"ReceiveTimeout","",""],[3,"SendTimeout","",""],[3,"Broadcast","",""],[11,"fmt","","",41],[6,"Get","",""],[6,"Set","",""],[11,"get","","",41],[11,"set","","",41],[11,"fmt","","",42],[6,"Get","",""],[6,"Set","",""],[11,"get","","",42],[11,"set","","",42],[11,"fmt","","",43],[6,"Get","",""],[6,"Set","",""],[11,"get","","",43],[11,"set","","",43],[11,"fmt","","",44],[6,"Get","",""],[6,"Set","",""],[11,"get","","",44],[11,"set","","",44],[11,"fmt","","",45],[6,"Get","",""],[6,"Set","",""],[11,"get","","",45],[11,"set","","",45],[11,"fmt","","",46],[6,"Get","",""],[6,"Set","",""],[11,"get","","",46],[11,"set","","",46],[11,"fmt","","",47],[6,"Get","",""],[6,"Set","",""],[11,"get","","",47],[11,"set","","",47],[11,"fmt","","",48],[6,"Get","",""],[6,"Set","",""],[11,"get","","",48],[11,"set","","",48],[11,"fmt","","",49],[6,"Get","",""],[6,"Set","",""],[11,"get","","",49],[11,"set","","",49],[11,"fmt","","",50],[6,"Get","",""],[6,"Set","",""],[11,"get","","",50],[11,"set","","",50],[17,"SOCK_NONBLOCK","nix::sys::socket",""],[17,"SOCK_CLOEXEC","",""],[8,"SockOpt","","Represents a socket option that can be accessed or set. Used as an argument\nto `getsockopt` and `setsockopt`."],[16,"Get","nix::sys::socket::SockOpt","Type of `getsockopt` return value"],[16,"Set","","Type of value used to set the socket option. Used as the argument to\n`setsockopt`."],[11,"fmt","nix::sys::socket","",36],[11,"eq","","",36],[11,"ne","","",36],[11,"hash","","",51],[11,"cmp","","",51],[11,"partial_cmp","","",51],[11,"lt","","",51],[11,"le","","",51],[11,"gt","","",51],[11,"ge","","",51],[11,"clone","","",51],[11,"eq","","",51],[11,"ne","","",51],[11,"empty","","Returns an empty set of flags.",51],[11,"all","","Returns the set containing all flags.",51],[11,"bits","","Returns the raw value of the flags currently stored.",51],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",51],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",51],[11,"is_empty","","Returns `true` if no flags are currently stored.",51],[11,"is_all","","Returns `true` if all flags are currently set.",51],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",51],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",51],[11,"insert","","Inserts the specified flags in-place.",51],[11,"remove","","Removes the specified flags in-place.",51],[11,"toggle","","Toggles the specified flags in-place.",51],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",51],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",51],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",51],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",51],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",51],[11,"fmt","","",31],[0,"stat","nix::sys",""],[6,"dev_t","nix::sys::stat",""],[3,"FileStat","",""],[12,"st_dev","","",52],[12,"st_ino","","",52],[12,"st_nlink","","",52],[12,"st_mode","","",52],[12,"st_uid","","",52],[12,"st_gid","","",52],[12,"__pad0","","",52],[12,"st_rdev","","",52],[12,"st_size","","",52],[12,"st_blksize","","",52],[12,"st_blocks","","",52],[12,"st_atime","","",52],[12,"st_atime_nsec","","",52],[12,"st_mtime","","",52],[12,"st_mtime_nsec","","",52],[12,"st_ctime","","",52],[12,"st_ctime_nsec","","",52],[12,"__unused","","",52],[3,"SFlag","",""],[3,"Mode","",""],[5,"mknod","",""],[5,"mkdev","",""],[5,"umask","",""],[5,"stat","",""],[5,"fstat","",""],[17,"S_IFREG","",""],[17,"S_IFCHR","",""],[17,"S_IFBLK","",""],[17,"S_IFIFO","",""],[17,"S_IFSOCK","",""],[17,"S_IRWXU","",""],[17,"S_IRUSR","",""],[17,"S_IWUSR","",""],[17,"S_IXUSR","",""],[17,"S_IRWXG","",""],[17,"S_IRGRP","",""],[17,"S_IWGRP","",""],[17,"S_IXGRP","",""],[17,"S_IRWXO","",""],[17,"S_IROTH","",""],[17,"S_IWOTH","",""],[17,"S_IXOTH","",""],[17,"S_ISUID","",""],[17,"S_ISGID","",""],[17,"S_ISVTX","",""],[11,"hash","","",53],[11,"cmp","","",53],[11,"partial_cmp","","",53],[11,"lt","","",53],[11,"le","","",53],[11,"gt","","",53],[11,"ge","","",53],[11,"clone","","",53],[11,"eq","","",53],[11,"ne","","",53],[11,"empty","","Returns an empty set of flags.",53],[11,"all","","Returns the set containing all flags.",53],[11,"bits","","Returns the raw value of the flags currently stored.",53],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",53],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",53],[11,"is_empty","","Returns `true` if no flags are currently stored.",53],[11,"is_all","","Returns `true` if all flags are currently set.",53],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",53],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",53],[11,"insert","","Inserts the specified flags in-place.",53],[11,"remove","","Removes the specified flags in-place.",53],[11,"toggle","","Toggles the specified flags in-place.",53],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",53],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",53],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",53],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",53],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",53],[11,"hash","","",54],[11,"cmp","","",54],[11,"partial_cmp","","",54],[11,"lt","","",54],[11,"le","","",54],[11,"gt","","",54],[11,"ge","","",54],[11,"clone","","",54],[11,"eq","","",54],[11,"ne","","",54],[11,"empty","","Returns an empty set of flags.",54],[11,"all","","Returns the set containing all flags.",54],[11,"bits","","Returns the raw value of the flags currently stored.",54],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",54],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",54],[11,"is_empty","","Returns `true` if no flags are currently stored.",54],[11,"is_all","","Returns `true` if all flags are currently set.",54],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",54],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",54],[11,"insert","","Inserts the specified flags in-place.",54],[11,"remove","","Removes the specified flags in-place.",54],[11,"toggle","","Toggles the specified flags in-place.",54],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",54],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",54],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",54],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",54],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",54],[11,"fmt","","",53],[0,"syscall","nix::sys","Indirect system call\n"],[5,"syscall","nix::sys::syscall",""],[6,"Syscall","",""],[7,"SYSPIVOTROOT","",""],[0,"termios","nix::sys",""],[3,"Termios","nix::sys::termios",""],[12,"c_iflag","","",55],[12,"c_oflag","","",55],[12,"c_cflag","","",55],[12,"c_lflag","","",55],[12,"c_line","","",55],[12,"c_cc","","",55],[12,"c_ispeed","","",55],[12,"c_ospeed","","",55],[3,"InputFlags","",""],[3,"OutputFlags","",""],[3,"ControlFlags","",""],[3,"LocalFlags","",""],[4,"SetArg","",""],[13,"TCSANOW","","",56],[13,"TCSADRAIN","","",56],[13,"TCSAFLUSH","","",56],[4,"FlushArg","",""],[13,"TCIFLUSH","","",57],[13,"TCOFLUSH","","",57],[13,"TCIOFLUSH","","",57],[4,"FlowArg","",""],[13,"TCOOFF","","",58],[13,"TCOON","","",58],[13,"TCIOFF","","",58],[13,"TCION","","",58],[5,"cfgetispeed","",""],[5,"cfgetospeed","",""],[5,"cfsetispeed","",""],[5,"cfsetospeed","",""],[5,"tcgetattr","",""],[5,"tcsetattr","",""],[5,"tcdrain","",""],[5,"tcflow","",""],[5,"tcflush","",""],[5,"tcsendbreak","",""],[11,"hash","","",59],[11,"cmp","","",59],[11,"partial_cmp","","",59],[11,"lt","","",59],[11,"le","","",59],[11,"gt","","",59],[11,"ge","","",59],[11,"clone","","",59],[11,"eq","","",59],[11,"ne","","",59],[11,"empty","","Returns an empty set of flags.",59],[11,"all","","Returns the set containing all flags.",59],[11,"bits","","Returns the raw value of the flags currently stored.",59],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",59],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",59],[11,"is_empty","","Returns `true` if no flags are currently stored.",59],[11,"is_all","","Returns `true` if all flags are currently set.",59],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",59],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",59],[11,"insert","","Inserts the specified flags in-place.",59],[11,"remove","","Removes the specified flags in-place.",59],[11,"toggle","","Toggles the specified flags in-place.",59],[11,"bitor","","Returns the union of the two sets of flags.",59],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",59],[11,"bitand","","Returns the intersection between the two sets of flags.",59],[11,"sub","","Returns the set difference of the two sets of flags.",59],[11,"not","","Returns the complement of this set of flags.",59],[11,"hash","","",60],[11,"cmp","","",60],[11,"partial_cmp","","",60],[11,"lt","","",60],[11,"le","","",60],[11,"gt","","",60],[11,"ge","","",60],[11,"clone","","",60],[11,"eq","","",60],[11,"ne","","",60],[11,"empty","","Returns an empty set of flags.",60],[11,"all","","Returns the set containing all flags.",60],[11,"bits","","Returns the raw value of the flags currently stored.",60],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",60],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",60],[11,"is_empty","","Returns `true` if no flags are currently stored.",60],[11,"is_all","","Returns `true` if all flags are currently set.",60],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",60],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",60],[11,"insert","","Inserts the specified flags in-place.",60],[11,"remove","","Removes the specified flags in-place.",60],[11,"toggle","","Toggles the specified flags in-place.",60],[11,"bitor","","Returns the union of the two sets of flags.",60],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",60],[11,"bitand","","Returns the intersection between the two sets of flags.",60],[11,"sub","","Returns the set difference of the two sets of flags.",60],[11,"not","","Returns the complement of this set of flags.",60],[11,"hash","","",61],[11,"cmp","","",61],[11,"partial_cmp","","",61],[11,"lt","","",61],[11,"le","","",61],[11,"gt","","",61],[11,"ge","","",61],[11,"clone","","",61],[11,"eq","","",61],[11,"ne","","",61],[11,"empty","","Returns an empty set of flags.",61],[11,"all","","Returns the set containing all flags.",61],[11,"bits","","Returns the raw value of the flags currently stored.",61],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",61],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",61],[11,"is_empty","","Returns `true` if no flags are currently stored.",61],[11,"is_all","","Returns `true` if all flags are currently set.",61],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",61],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",61],[11,"insert","","Inserts the specified flags in-place.",61],[11,"remove","","Removes the specified flags in-place.",61],[11,"toggle","","Toggles the specified flags in-place.",61],[11,"bitor","","Returns the union of the two sets of flags.",61],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",61],[11,"bitand","","Returns the intersection between the two sets of flags.",61],[11,"sub","","Returns the set difference of the two sets of flags.",61],[11,"not","","Returns the complement of this set of flags.",61],[11,"hash","","",62],[11,"cmp","","",62],[11,"partial_cmp","","",62],[11,"lt","","",62],[11,"le","","",62],[11,"gt","","",62],[11,"ge","","",62],[11,"clone","","",62],[11,"eq","","",62],[11,"ne","","",62],[11,"empty","","Returns an empty set of flags.",62],[11,"all","","Returns the set containing all flags.",62],[11,"bits","","Returns the raw value of the flags currently stored.",62],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",62],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",62],[11,"is_empty","","Returns `true` if no flags are currently stored.",62],[11,"is_all","","Returns `true` if all flags are currently set.",62],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",62],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",62],[11,"insert","","Inserts the specified flags in-place.",62],[11,"remove","","Removes the specified flags in-place.",62],[11,"toggle","","Toggles the specified flags in-place.",62],[11,"bitor","","Returns the union of the two sets of flags.",62],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",62],[11,"bitand","","Returns the intersection between the two sets of flags.",62],[11,"sub","","Returns the set difference of the two sets of flags.",62],[11,"not","","Returns the complement of this set of flags.",62],[6,"tcflag_t","",""],[6,"cc_t","",""],[6,"speed_t","",""],[17,"VEOF","",""],[17,"VEOL","",""],[17,"VEOL2","",""],[17,"VERASE","",""],[17,"VWERASE","",""],[17,"VKILL","",""],[17,"VREPRINT","",""],[17,"VINTR","",""],[17,"VQUIT","",""],[17,"VSUSP","",""],[17,"VSTART","",""],[17,"VSTOP","",""],[17,"VLNEXT","",""],[17,"VDISCARD","",""],[17,"VMIN","",""],[17,"VTIME","",""],[17,"NCCS","",""],[17,"IGNBRK","",""],[17,"BRKINT","",""],[17,"IGNPAR","",""],[17,"PARMRK","",""],[17,"INPCK","",""],[17,"ISTRIP","",""],[17,"INLCR","",""],[17,"IGNCR","",""],[17,"ICRNL","",""],[17,"IXON","",""],[17,"IXOFF","",""],[17,"IXANY","",""],[17,"IMAXBEL","",""],[17,"IUTF8","",""],[17,"OPOST","",""],[17,"ONLCR","",""],[17,"CSIZE","",""],[17,"CS5","",""],[17,"CS6","",""],[17,"CS7","",""],[17,"CS8","",""],[17,"CSTOPB","",""],[17,"CREAD","",""],[17,"PARENB","",""],[17,"PARODD","",""],[17,"HUPCL","",""],[17,"CLOCAL","",""],[17,"CRTSCTS","",""],[17,"ECHOKE","",""],[17,"ECHOE","",""],[17,"ECHOK","",""],[17,"ECHO","",""],[17,"ECHONL","",""],[17,"ECHOPRT","",""],[17,"ECHOCTL","",""],[17,"ISIG","",""],[17,"ICANON","",""],[17,"IEXTEN","",""],[17,"EXTPROC","",""],[17,"TOSTOP","",""],[17,"FLUSHO","",""],[17,"PENDIN","",""],[17,"NOFLSH","",""],[17,"NL0","",""],[17,"NL1","",""],[17,"TAB0","",""],[17,"TAB1","",""],[17,"TAB2","",""],[17,"TAB3","",""],[17,"CR0","",""],[17,"CR1","",""],[17,"CR2","",""],[17,"CR3","",""],[17,"FF0","",""],[17,"FF1","",""],[17,"BS0","",""],[17,"BS1","",""],[17,"VT0","",""],[17,"VT1","",""],[11,"hash","","",59],[11,"cmp","","",59],[11,"partial_cmp","","",59],[11,"lt","","",59],[11,"le","","",59],[11,"gt","","",59],[11,"ge","","",59],[11,"clone","","",59],[11,"eq","","",59],[11,"ne","","",59],[11,"empty","","Returns an empty set of flags.",59],[11,"all","","Returns the set containing all flags.",59],[11,"bits","","Returns the raw value of the flags currently stored.",59],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",59],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",59],[11,"is_empty","","Returns `true` if no flags are currently stored.",59],[11,"is_all","","Returns `true` if all flags are currently set.",59],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",59],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",59],[11,"insert","","Inserts the specified flags in-place.",59],[11,"remove","","Removes the specified flags in-place.",59],[11,"toggle","","Toggles the specified flags in-place.",59],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",59],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",59],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",59],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",59],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",59],[11,"hash","","",60],[11,"cmp","","",60],[11,"partial_cmp","","",60],[11,"lt","","",60],[11,"le","","",60],[11,"gt","","",60],[11,"ge","","",60],[11,"clone","","",60],[11,"eq","","",60],[11,"ne","","",60],[11,"empty","","Returns an empty set of flags.",60],[11,"all","","Returns the set containing all flags.",60],[11,"bits","","Returns the raw value of the flags currently stored.",60],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",60],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",60],[11,"is_empty","","Returns `true` if no flags are currently stored.",60],[11,"is_all","","Returns `true` if all flags are currently set.",60],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",60],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",60],[11,"insert","","Inserts the specified flags in-place.",60],[11,"remove","","Removes the specified flags in-place.",60],[11,"toggle","","Toggles the specified flags in-place.",60],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",60],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",60],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",60],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",60],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",60],[11,"hash","","",61],[11,"cmp","","",61],[11,"partial_cmp","","",61],[11,"lt","","",61],[11,"le","","",61],[11,"gt","","",61],[11,"ge","","",61],[11,"clone","","",61],[11,"eq","","",61],[11,"ne","","",61],[11,"empty","","Returns an empty set of flags.",61],[11,"all","","Returns the set containing all flags.",61],[11,"bits","","Returns the raw value of the flags currently stored.",61],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",61],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",61],[11,"is_empty","","Returns `true` if no flags are currently stored.",61],[11,"is_all","","Returns `true` if all flags are currently set.",61],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",61],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",61],[11,"insert","","Inserts the specified flags in-place.",61],[11,"remove","","Removes the specified flags in-place.",61],[11,"toggle","","Toggles the specified flags in-place.",61],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",61],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",61],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",61],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",61],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",61],[11,"hash","","",62],[11,"cmp","","",62],[11,"partial_cmp","","",62],[11,"lt","","",62],[11,"le","","",62],[11,"gt","","",62],[11,"ge","","",62],[11,"clone","","",62],[11,"eq","","",62],[11,"ne","","",62],[11,"empty","","Returns an empty set of flags.",62],[11,"all","","Returns the set containing all flags.",62],[11,"bits","","Returns the raw value of the flags currently stored.",62],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",62],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",62],[11,"is_empty","","Returns `true` if no flags are currently stored.",62],[11,"is_all","","Returns `true` if all flags are currently set.",62],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",62],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",62],[11,"insert","","Inserts the specified flags in-place.",62],[11,"remove","","Removes the specified flags in-place.",62],[11,"toggle","","Toggles the specified flags in-place.",62],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",62],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",62],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",62],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",62],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",62],[0,"utsname","nix::sys",""],[3,"UtsName","nix::sys::utsname",""],[5,"uname","",""],[11,"sysname","","",63],[11,"nodename","","",63],[11,"release","","",63],[11,"version","","",63],[11,"machine","","",63],[0,"wait","nix::sys",""],[3,"WaitPidFlag","nix::sys::wait",""],[4,"WaitStatus","",""],[13,"Exited","","",64],[13,"StillAlive","","",64],[5,"waitpid","",""],[17,"WNOHANG","",""],[11,"hash","","",65],[11,"cmp","","",65],[11,"partial_cmp","","",65],[11,"lt","","",65],[11,"le","","",65],[11,"gt","","",65],[11,"ge","","",65],[11,"clone","","",65],[11,"eq","","",65],[11,"ne","","",65],[11,"empty","","Returns an empty set of flags.",65],[11,"all","","Returns the set containing all flags.",65],[11,"bits","","Returns the raw value of the flags currently stored.",65],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",65],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",65],[11,"is_empty","","Returns `true` if no flags are currently stored.",65],[11,"is_all","","Returns `true` if all flags are currently set.",65],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",65],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",65],[11,"insert","","Inserts the specified flags in-place.",65],[11,"remove","","Removes the specified flags in-place.",65],[11,"toggle","","Toggles the specified flags in-place.",65],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",65],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",65],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",65],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",65],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",65],[0,"mman","nix::sys",""],[5,"mlock","nix::sys::mman",""],[5,"munlock","",""],[5,"mmap","","Calls to mmap are inherently unsafe, so they must be made in an unsafe block. Typically\na higher-level abstraction will hide the unsafe interactions with the mmap'd region."],[5,"munmap","",""],[5,"madvise","",""],[5,"msync","",""],[5,"shm_open","",""],[5,"shm_unlink","",""],[6,"MmapFlag","",""],[6,"MmapProt","",""],[6,"MmapAdvise","",""],[6,"MmapSync","",""],[17,"MAP_SHARED","",""],[17,"MAP_PRIVATE","",""],[17,"MAP_FIXED","",""],[17,"MAP_FILE","",""],[17,"MAP_ANONYMOUS","",""],[17,"MAP_ANON","",""],[17,"MAP_32BIT","",""],[17,"MAP_GROWSDOWN","",""],[17,"MAP_DENYWRITE","",""],[17,"MAP_EXECUTABLE","",""],[17,"MAP_LOCKED","",""],[17,"MAP_NORESERVE","",""],[17,"MAP_POPULATE","",""],[17,"MAP_NONBLOCK","",""],[17,"MAP_STACK","",""],[17,"MAP_HUGETLB","",""],[17,"PROT_READ","",""],[17,"PROT_WRITE","",""],[17,"PROT_EXEC","",""],[17,"PROT_NONE","",""],[17,"PROT_GROWSDOWN","",""],[17,"PROT_GROWSUP","",""],[17,"MADV_NORMAL","",""],[17,"MADV_RANDOM","",""],[17,"MADV_SEQUENTIAL","",""],[17,"MADV_WILLNEED","",""],[17,"MADV_DONTNEED","",""],[17,"MADV_REMOVE","",""],[17,"MADV_DONTFORK","",""],[17,"MADV_DOFORK","",""],[17,"MADV_MERGEABLE","",""],[17,"MADV_UNMERGEABLE","",""],[17,"MADV_HUGEPAGE","",""],[17,"MADV_NOHUGEPAGE","",""],[17,"MADV_DONTDUMP","",""],[17,"MADV_DODUMP","",""],[17,"MADV_HWPOISON","",""],[17,"MS_ASYNC","",""],[17,"MS_SYNC","",""],[17,"MS_INVALIDATE","",""],[17,"MAP_FAILED","",""],[0,"uio","nix::sys",""],[3,"IoVec","nix::sys::uio",""],[5,"writev","",""],[5,"readv","",""],[11,"as_slice","","",66],[11,"from_slice","","",66],[11,"from_mut_slice","","",66],[0,"time","nix::sys",""],[3,"TimeVal","nix::sys::time",""],[12,"tv_sec","","",67],[12,"tv_usec","","",67],[11,"fmt","","",67],[11,"cmp","","",67],[11,"partial_cmp","","",67],[11,"lt","","",67],[11,"le","","",67],[11,"gt","","",67],[11,"ge","","",67],[11,"eq","","",67],[11,"ne","","",67],[11,"clone","","",67],[11,"zero","","",67],[11,"hours","","",67],[11,"minutes","","",67],[11,"seconds","","",67],[11,"milliseconds","","",67],[11,"microseconds","","Makes a new `TimeVal` with given number of microseconds.",67],[11,"num_hours","","",67],[11,"num_minutes","","",67],[11,"num_seconds","","",67],[11,"num_milliseconds","","",67],[11,"num_microseconds","","",67],[6,"Output","",""],[11,"neg","","",67],[6,"Output","",""],[11,"add","","",67],[6,"Output","",""],[11,"sub","","",67],[6,"Output","",""],[11,"mul","","",67],[6,"Output","",""],[11,"div","","",67],[11,"fmt","","",67],[0,"unistd","nix","Standard symbolic constants and types\n"],[4,"Fork","nix::unistd",""],[13,"Parent","","",68],[13,"Child","","",68],[5,"pivot_root","",""],[5,"fork","",""],[5,"dup","",""],[5,"dup2","",""],[5,"dup3","",""],[5,"chdir","",""],[5,"execve","",""],[5,"daemon","",""],[5,"sethostname","",""],[5,"gethostname","",""],[5,"close","",""],[5,"read","",""],[5,"write","",""],[5,"pipe","",""],[5,"pipe2","",""],[5,"ftruncate","",""],[5,"isatty","",""],[5,"unlink","",""],[11,"is_child","","",68],[11,"is_parent","","",68],[6,"NixResult","nix",""],[8,"NixPath","",""],[10,"with_nix_path","","",69]],"paths":[[4,"c_void"],[4,"NixError"],[3,"Path"],[3,"PathBuf"],[4,"Errno"],[3,"flock"],[4,"FcntlArg"],[3,"OFlag"],[3,"FdFlag"],[3,"MsFlags"],[3,"MntFlags"],[3,"CpuSet"],[3,"EpollEvent"],[4,"EpollOp"],[3,"EpollEventKind"],[3,"EventFdFlag"],[3,"Winsize"],[4,"IoctlArg"],[3,"siginfo"],[3,"sigaction"],[3,"SockFlag"],[3,"SigSet"],[3,"SigAction"],[3,"in_addr"],[3,"in6_addr"],[3,"sockaddr"],[3,"sockaddr_storage"],[3,"sockaddr_in"],[3,"sockaddr_in6"],[3,"sockaddr_un"],[3,"ip_mreq"],[3,"linger"],[4,"AddressFamily"],[4,"SockAddr"],[4,"InetAddr"],[4,"IpAddr"],[4,"SockType"],[4,"SockLevel"],[3,"Ipv4Addr"],[3,"Ipv6Addr"],[3,"UnixAddr"],[3,"ReuseAddr"],[3,"ReusePort"],[3,"TcpNoDelay"],[3,"Linger"],[3,"IpAddMembership"],[3,"IpDropMembership"],[3,"IpMulticastTtl"],[3,"ReceiveTimeout"],[3,"SendTimeout"],[3,"Broadcast"],[3,"SockFlag"],[3,"FileStat"],[3,"SFlag"],[3,"Mode"],[3,"Termios"],[4,"SetArg"],[4,"FlushArg"],[4,"FlowArg"],[3,"InputFlags"],[3,"OutputFlags"],[3,"ControlFlags"],[3,"LocalFlags"],[3,"UtsName"],[4,"WaitStatus"],[3,"WaitPidFlag"],[3,"IoVec"],[3,"TimeVal"],[4,"Fork"],[8,"NixPath"]]};
initSearch(searchIndex);
