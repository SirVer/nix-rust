var searchIndex = {};
searchIndex['nix'] = {"items":[[0,"","nix",""],[6,"c_int","",""],[4,"c_void","","Type used to construct void pointers for use with C."],[13,"__variant1","","",0],[13,"__variant2","","",0],[4,"NixError","",""],[13,"Sys","","",1],[13,"InvalidPath","","",1],[5,"from_ffi","",""],[11,"eq","","",1],[11,"ne","","",1],[11,"fmt","","",1],[11,"clone","","",1],[11,"with_nix_path","core::option","",2],[0,"errno","nix",""],[4,"Errno","nix::errno",""],[13,"UnknownErrno","","",3],[13,"EPERM","","",3],[13,"ENOENT","","",3],[13,"ESRCH","","",3],[13,"EINTR","","",3],[13,"EIO","","",3],[13,"ENXIO","","",3],[13,"E2BIG","","",3],[13,"ENOEXEC","","",3],[13,"EBADF","","",3],[13,"ECHILD","","",3],[13,"EAGAIN","","",3],[13,"ENOMEM","","",3],[13,"EACCES","","",3],[13,"EFAULT","","",3],[13,"ENOTBLK","","",3],[13,"EBUSY","","",3],[13,"EEXIST","","",3],[13,"EXDEV","","",3],[13,"ENODEV","","",3],[13,"ENOTDIR","","",3],[13,"EISDIR","","",3],[13,"EINVAL","","",3],[13,"ENFILE","","",3],[13,"EMFILE","","",3],[13,"ENOTTY","","",3],[13,"ETXTBSY","","",3],[13,"EFBIG","","",3],[13,"ENOSPC","","",3],[13,"ESPIPE","","",3],[13,"EROFS","","",3],[13,"EMLINK","","",3],[13,"EPIPE","","",3],[13,"EDOM","","",3],[13,"ERANGE","","",3],[13,"EDEADLK","","",3],[13,"ENAMETOOLONG","","",3],[13,"ENOLCK","","",3],[13,"ENOSYS","","",3],[13,"ENOTEMPTY","","",3],[13,"ELOOP","","",3],[13,"ENOMSG","","",3],[13,"EIDRM","","",3],[13,"ECHRNG","","",3],[13,"EL2NSYNC","","",3],[13,"EL3HLT","","",3],[13,"EL3RST","","",3],[13,"ELNRNG","","",3],[13,"EUNATCH","","",3],[13,"ENOCSI","","",3],[13,"EL2HLT","","",3],[13,"EBADE","","",3],[13,"EBADR","","",3],[13,"EXFULL","","",3],[13,"ENOANO","","",3],[13,"EBADRQC","","",3],[13,"EBADSLT","","",3],[13,"EBFONT","","",3],[13,"ENOSTR","","",3],[13,"ENODATA","","",3],[13,"ETIME","","",3],[13,"ENOSR","","",3],[13,"ENONET","","",3],[13,"ENOPKG","","",3],[13,"EREMOTE","","",3],[13,"ENOLINK","","",3],[13,"EADV","","",3],[13,"ESRMNT","","",3],[13,"ECOMM","","",3],[13,"EPROTO","","",3],[13,"EMULTIHOP","","",3],[13,"EDOTDOT","","",3],[13,"EBADMSG","","",3],[13,"EOVERFLOW","","",3],[13,"ENOTUNIQ","","",3],[13,"EBADFD","","",3],[13,"EREMCHG","","",3],[13,"ELIBACC","","",3],[13,"ELIBBAD","","",3],[13,"ELIBSCN","","",3],[13,"ELIBMAX","","",3],[13,"ELIBEXEC","","",3],[13,"EILSEQ","","",3],[13,"ERESTART","","",3],[13,"ESTRPIPE","","",3],[13,"EUSERS","","",3],[13,"ENOTSOCK","","",3],[13,"EDESTADDRREQ","","",3],[13,"EMSGSIZE","","",3],[13,"EPROTOTYPE","","",3],[13,"ENOPROTOOPT","","",3],[13,"EPROTONOSUPPORT","","",3],[13,"ESOCKTNOSUPPORT","","",3],[13,"EOPNOTSUPP","","",3],[13,"EPFNOSUPPORT","","",3],[13,"EAFNOSUPPORT","","",3],[13,"EADDRINUSE","","",3],[13,"EADDRNOTAVAIL","","",3],[13,"ENETDOWN","","",3],[13,"ENETUNREACH","","",3],[13,"ENETRESET","","",3],[13,"ECONNABORTED","","",3],[13,"ECONNRESET","","",3],[13,"ENOBUFS","","",3],[13,"EISCONN","","",3],[13,"ENOTCONN","","",3],[13,"ESHUTDOWN","","",3],[13,"ETOOMANYREFS","","",3],[13,"ETIMEDOUT","","",3],[13,"ECONNREFUSED","","",3],[13,"EHOSTDOWN","","",3],[13,"EHOSTUNREACH","","",3],[13,"EALREADY","","",3],[13,"EINPROGRESS","","",3],[13,"ESTALE","","",3],[13,"EUCLEAN","","",3],[13,"ENOTNAM","","",3],[13,"ENAVAIL","","",3],[13,"EISNAM","","",3],[13,"EREMOTEIO","","",3],[13,"EDQUOT","","",3],[13,"ENOMEDIUM","","",3],[13,"EMEDIUMTYPE","","",3],[13,"ECANCELED","","",3],[13,"ENOKEY","","",3],[13,"EKEYEXPIRED","","",3],[13,"EKEYREVOKED","","",3],[13,"EKEYREJECTED","","",3],[13,"EOWNERDEAD","","",3],[13,"ENOTRECOVERABLE","","",3],[13,"ERFKILL","","",3],[13,"EHWPOISON","","",3],[11,"from_i64","","",3],[11,"from_u64","","",3],[11,"eq","","",3],[11,"ne","","",3],[11,"clone","","",3],[11,"fmt","","",3],[11,"last","","",3],[11,"desc","","",3],[17,"EWOULDBLOCK","",""],[17,"EDEADLOCK","",""],[11,"from_i64","","",3],[11,"from_u64","","",3],[11,"eq","","",3],[11,"ne","","",3],[11,"clone","","",3],[11,"fmt","","",3],[11,"last","","",3],[11,"desc","","",3],[0,"features","nix",""],[5,"socket_atomic_cloexec","nix::features",""],[0,"fcntl","nix",""],[3,"OFlag","nix::fcntl",""],[3,"FdFlag","",""],[3,"flock","",""],[12,"l_type","","",4],[12,"l_whence","","",4],[12,"l_start","","",4],[12,"l_len","","",4],[12,"l_pid","","",4],[12,"l_sysid","","",4],[4,"FcntlArg","",""],[13,"F_DUPFD","","",5],[13,"F_DUPFD_CLOEXEC","","",5],[13,"F_GETFD","","",5],[13,"F_SETFD","","",5],[13,"F_GETFL","","",5],[13,"F_SETFL","","",5],[13,"F_SETLK","","",5],[13,"F_SETLKW","","",5],[13,"F_GETLK","","",5],[13,"F_OFD_SETLK","","",5],[13,"F_OFD_SETLKW","","",5],[13,"F_OFD_GETLK","","",5],[5,"open","",""],[5,"fcntl","",""],[11,"hash","","",6],[11,"cmp","","",6],[11,"partial_cmp","","",6],[11,"lt","","",6],[11,"le","","",6],[11,"gt","","",6],[11,"ge","","",6],[11,"clone","","",6],[11,"eq","","",6],[11,"ne","","",6],[11,"empty","","Returns an empty set of flags.",6],[11,"all","","Returns the set containing all flags.",6],[11,"bits","","Returns the raw value of the flags currently stored.",6],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",6],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",6],[11,"is_empty","","Returns `true` if no flags are currently stored.",6],[11,"is_all","","Returns `true` if all flags are currently set.",6],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",6],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",6],[11,"insert","","Inserts the specified flags in-place.",6],[11,"remove","","Removes the specified flags in-place.",6],[11,"toggle","","Toggles the specified flags in-place.",6],[11,"bitor","","Returns the union of the two sets of flags.",6],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",6],[11,"bitand","","Returns the intersection between the two sets of flags.",6],[11,"sub","","Returns the set difference of the two sets of flags.",6],[11,"not","","Returns the complement of this set of flags.",6],[11,"hash","","",7],[11,"cmp","","",7],[11,"partial_cmp","","",7],[11,"lt","","",7],[11,"le","","",7],[11,"gt","","",7],[11,"ge","","",7],[11,"clone","","",7],[11,"eq","","",7],[11,"ne","","",7],[11,"empty","","Returns an empty set of flags.",7],[11,"all","","Returns the set containing all flags.",7],[11,"bits","","Returns the raw value of the flags currently stored.",7],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",7],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",7],[11,"is_empty","","Returns `true` if no flags are currently stored.",7],[11,"is_all","","Returns `true` if all flags are currently set.",7],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",7],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",7],[11,"insert","","Inserts the specified flags in-place.",7],[11,"remove","","Removes the specified flags in-place.",7],[11,"toggle","","Toggles the specified flags in-place.",7],[11,"bitor","","Returns the union of the two sets of flags.",7],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",7],[11,"bitand","","Returns the intersection between the two sets of flags.",7],[11,"sub","","Returns the set difference of the two sets of flags.",7],[11,"not","","Returns the complement of this set of flags.",7],[6,"Fd","",""],[17,"O_ACCMODE","",""],[17,"O_RDONLY","",""],[17,"O_WRONLY","",""],[17,"O_RDWR","",""],[17,"O_CREAT","",""],[17,"O_EXCL","",""],[17,"O_NOCTTY","",""],[17,"O_TRUNC","",""],[17,"O_APPEND","",""],[17,"O_NONBLOCK","",""],[17,"O_DSYNC","",""],[17,"O_DIRECT","",""],[17,"O_LARGEFILE","",""],[17,"O_DIRECTORY","",""],[17,"O_NOFOLLOW","",""],[17,"O_NOATIME","",""],[17,"O_CLOEXEC","",""],[17,"O_SYNC","",""],[17,"O_PATH","",""],[17,"O_TMPFILE","",""],[17,"O_NDELAY","",""],[17,"FD_CLOEXEC","",""],[11,"hash","","",6],[11,"cmp","","",6],[11,"partial_cmp","","",6],[11,"lt","","",6],[11,"le","","",6],[11,"gt","","",6],[11,"ge","","",6],[11,"clone","","",6],[11,"eq","","",6],[11,"ne","","",6],[11,"empty","","Returns an empty set of flags.",6],[11,"all","","Returns the set containing all flags.",6],[11,"bits","","Returns the raw value of the flags currently stored.",6],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",6],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",6],[11,"is_empty","","Returns `true` if no flags are currently stored.",6],[11,"is_all","","Returns `true` if all flags are currently set.",6],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",6],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",6],[11,"insert","","Inserts the specified flags in-place.",6],[11,"remove","","Removes the specified flags in-place.",6],[11,"toggle","","Toggles the specified flags in-place.",6],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",6],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",6],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",6],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",6],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",6],[11,"hash","","",7],[11,"cmp","","",7],[11,"partial_cmp","","",7],[11,"lt","","",7],[11,"le","","",7],[11,"gt","","",7],[11,"ge","","",7],[11,"clone","","",7],[11,"eq","","",7],[11,"ne","","",7],[11,"empty","","Returns an empty set of flags.",7],[11,"all","","Returns the set containing all flags.",7],[11,"bits","","Returns the raw value of the flags currently stored.",7],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",7],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",7],[11,"is_empty","","Returns `true` if no flags are currently stored.",7],[11,"is_all","","Returns `true` if all flags are currently set.",7],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",7],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",7],[11,"insert","","Inserts the specified flags in-place.",7],[11,"remove","","Removes the specified flags in-place.",7],[11,"toggle","","Toggles the specified flags in-place.",7],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",7],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",7],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",7],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",7],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",7],[0,"mount","nix",""],[3,"MsFlags","nix::mount",""],[3,"MntFlags","",""],[5,"mount","",""],[5,"umount","",""],[5,"umount2","",""],[17,"MS_RDONLY","",""],[17,"MS_NOSUID","",""],[17,"MS_NODEV","",""],[17,"MS_NOEXEC","",""],[17,"MS_SYNCHRONOUS","",""],[17,"MS_REMOUNT","",""],[17,"MS_MANDLOCK","",""],[17,"MS_DIRSYNC","",""],[17,"MS_NOATIME","",""],[17,"MS_NODIRATIME","",""],[17,"MS_BIND","",""],[17,"MS_MOVE","",""],[17,"MS_REC","",""],[17,"MS_VERBOSE","",""],[17,"MS_SILENT","",""],[17,"MS_POSIXACL","",""],[17,"MS_UNBINDABLE","",""],[17,"MS_PRIVATE","",""],[17,"MS_SLAVE","",""],[17,"MS_SHARED","",""],[17,"MS_RELATIME","",""],[17,"MS_KERNMOUNT","",""],[17,"MS_I_VERSION","",""],[17,"MS_STRICTATIME","",""],[17,"MS_NOSEC","",""],[17,"MS_BORN","",""],[17,"MS_ACTIVE","",""],[17,"MS_NOUSER","",""],[17,"MS_RMT_MASK","",""],[17,"MS_MGC_VAL","",""],[17,"MS_MGC_MSK","",""],[17,"MNT_FORCE","",""],[17,"MNT_DETATCH","",""],[17,"MNT_EXPIRE","",""],[11,"hash","","",8],[11,"cmp","","",8],[11,"partial_cmp","","",8],[11,"lt","","",8],[11,"le","","",8],[11,"gt","","",8],[11,"ge","","",8],[11,"clone","","",8],[11,"eq","","",8],[11,"ne","","",8],[11,"empty","","Returns an empty set of flags.",8],[11,"all","","Returns the set containing all flags.",8],[11,"bits","","Returns the raw value of the flags currently stored.",8],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",8],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",8],[11,"is_empty","","Returns `true` if no flags are currently stored.",8],[11,"is_all","","Returns `true` if all flags are currently set.",8],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",8],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",8],[11,"insert","","Inserts the specified flags in-place.",8],[11,"remove","","Removes the specified flags in-place.",8],[11,"toggle","","Toggles the specified flags in-place.",8],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",8],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",8],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",8],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",8],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",8],[11,"hash","","",9],[11,"cmp","","",9],[11,"partial_cmp","","",9],[11,"lt","","",9],[11,"le","","",9],[11,"gt","","",9],[11,"ge","","",9],[11,"clone","","",9],[11,"eq","","",9],[11,"ne","","",9],[11,"empty","","Returns an empty set of flags.",9],[11,"all","","Returns the set containing all flags.",9],[11,"bits","","Returns the raw value of the flags currently stored.",9],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",9],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",9],[11,"is_empty","","Returns `true` if no flags are currently stored.",9],[11,"is_all","","Returns `true` if all flags are currently set.",9],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",9],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",9],[11,"insert","","Inserts the specified flags in-place.",9],[11,"remove","","Removes the specified flags in-place.",9],[11,"toggle","","Toggles the specified flags in-place.",9],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",9],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",9],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",9],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",9],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",9],[0,"sched","nix",""],[3,"CpuSet","nix::sched",""],[5,"sched_setaffinity","",""],[5,"clone","",""],[5,"unshare","",""],[6,"CloneFlags","",""],[6,"CloneCb","",""],[6,"CpuMask","",""],[7,"CLONE_VM","",""],[7,"CLONE_FS","",""],[7,"CLONE_FILES","",""],[7,"CLONE_SIGHAND","",""],[7,"CLONE_PTRACE","",""],[7,"CLONE_VFORK","",""],[7,"CLONE_PARENT","",""],[7,"CLONE_THREAD","",""],[7,"CLONE_NEWNS","",""],[7,"CLONE_SYSVSEM","",""],[7,"CLONE_SETTLS","",""],[7,"CLONE_PARENT_SETTID","",""],[7,"CLONE_CHILD_CLEARTID","",""],[7,"CLONE_DETACHED","",""],[7,"CLONE_UNTRACED","",""],[7,"CLONE_CHILD_SETTID","",""],[7,"CLONE_NEWUTS","",""],[7,"CLONE_NEWIPC","",""],[7,"CLONE_NEWUSER","",""],[7,"CLONE_NEWPID","",""],[7,"CLONE_NEWNET","",""],[7,"CLONE_IO","",""],[11,"new","","",10],[11,"set","","",10],[11,"unset","","",10],[0,"sys","nix",""],[0,"epoll","nix::sys",""],[3,"EpollEventKind","nix::sys::epoll",""],[3,"EpollEvent","",""],[12,"events","","",11],[12,"data","","",11],[4,"EpollOp","",""],[13,"EpollCtlAdd","","",12],[13,"EpollCtlDel","","",12],[13,"EpollCtlMod","","",12],[5,"epoll_create","",""],[5,"epoll_ctl","",""],[5,"epoll_wait","",""],[17,"EPOLLIN","",""],[17,"EPOLLPRI","",""],[17,"EPOLLOUT","",""],[17,"EPOLLRDNORM","",""],[17,"EPOLLRDBAND","",""],[17,"EPOLLWRNORM","",""],[17,"EPOLLWRBAND","",""],[17,"EPOLLMSG","",""],[17,"EPOLLERR","",""],[17,"EPOLLHUP","",""],[17,"EPOLLRDHUP","",""],[17,"EPOLLWAKEUP","",""],[17,"EPOLLONESHOT","",""],[17,"EPOLLET","",""],[11,"hash","","",13],[11,"cmp","","",13],[11,"partial_cmp","","",13],[11,"lt","","",13],[11,"le","","",13],[11,"gt","","",13],[11,"ge","","",13],[11,"clone","","",13],[11,"eq","","",13],[11,"ne","","",13],[11,"empty","","Returns an empty set of flags.",13],[11,"all","","Returns the set containing all flags.",13],[11,"bits","","Returns the raw value of the flags currently stored.",13],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",13],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",13],[11,"is_empty","","Returns `true` if no flags are currently stored.",13],[11,"is_all","","Returns `true` if all flags are currently set.",13],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",13],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",13],[11,"insert","","Inserts the specified flags in-place.",13],[11,"remove","","Removes the specified flags in-place.",13],[11,"toggle","","Toggles the specified flags in-place.",13],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",13],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",13],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",13],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",13],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",13],[11,"fmt","","",13],[0,"eventfd","nix::sys",""],[3,"EventFdFlag","nix::sys::eventfd",""],[5,"eventfd","",""],[17,"EFD_CLOEXEC","",""],[17,"EFD_NONBLOCK","",""],[17,"EFD_SEMAPHORE","",""],[11,"hash","","",14],[11,"cmp","","",14],[11,"partial_cmp","","",14],[11,"lt","","",14],[11,"le","","",14],[11,"gt","","",14],[11,"ge","","",14],[11,"clone","","",14],[11,"eq","","",14],[11,"ne","","",14],[11,"empty","","Returns an empty set of flags.",14],[11,"all","","Returns the set containing all flags.",14],[11,"bits","","Returns the raw value of the flags currently stored.",14],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",14],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",14],[11,"is_empty","","Returns `true` if no flags are currently stored.",14],[11,"is_all","","Returns `true` if all flags are currently set.",14],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",14],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",14],[11,"insert","","Inserts the specified flags in-place.",14],[11,"remove","","Removes the specified flags in-place.",14],[11,"toggle","","Toggles the specified flags in-place.",14],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",14],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",14],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",14],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",14],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",14],[0,"ioctl","nix::sys",""],[3,"Winsize","nix::sys::ioctl",""],[12,"ws_row","","",15],[12,"ws_col","","",15],[12,"ws_xpixel","","",15],[12,"ws_ypixel","","",15],[4,"IoctlArg","",""],[13,"TIOCGWINSZ","","",16],[5,"ioctl","",""],[11,"fmt","","",15],[0,"signal","nix::sys",""],[17,"SIGHUP","nix::sys::signal",""],[17,"SIGINT","",""],[17,"SIGQUIT","",""],[17,"SIGILL","",""],[17,"SIGABRT","",""],[17,"SIGFPE","",""],[17,"SIGKILL","",""],[17,"SIGSEGV","",""],[17,"SIGPIPE","",""],[17,"SIGALRM","",""],[17,"SIGTERM","",""],[3,"SigSet","",""],[3,"SigAction","",""],[5,"sigaction","",""],[5,"kill","",""],[0,"signal","",""],[3,"SockFlag","nix::sys::signal::signal",""],[3,"siginfo","",""],[12,"pid","","",17],[12,"uid","","",17],[12,"status","","",17],[3,"sigaction","",""],[12,"sa_handler","","",18],[12,"sa_mask","","",18],[12,"sa_flags","","",18],[3,"sigset_t","",""],[17,"SA_NOCLDSTOP","",""],[17,"SA_NOCLDWAIT","",""],[17,"SA_NODEFER","",""],[17,"SA_ONSTACK","",""],[17,"SA_RESETHAND","",""],[17,"SA_RESTART","",""],[17,"SA_SIGINFO","",""],[17,"SIGTRAP","",""],[17,"SIGIOT","",""],[17,"SIGBUS","",""],[17,"SIGUSR1","",""],[17,"SIGUSR2","",""],[17,"SIGSTKFLT","",""],[17,"SIGCHLD","",""],[17,"SIGCONT","",""],[17,"SIGSTOP","",""],[17,"SIGTSTP","",""],[17,"SIGTTIN","",""],[17,"SIGTTOU","",""],[17,"SIGURG","",""],[17,"SIGXCPU","",""],[17,"SIGXFSZ","",""],[17,"SIGVTALRM","",""],[17,"SIGPROF","",""],[17,"SIGWINCH","",""],[17,"SIGIO","",""],[17,"SIGPOLL","",""],[17,"SIGPWR","",""],[17,"SIGSYS","",""],[17,"SIGUNUSED","",""],[11,"hash","","",19],[11,"cmp","","",19],[11,"partial_cmp","","",19],[11,"lt","","",19],[11,"le","","",19],[11,"gt","","",19],[11,"ge","","",19],[11,"clone","","",19],[11,"eq","","",19],[11,"ne","","",19],[11,"empty","","Returns an empty set of flags.",19],[11,"all","","Returns the set containing all flags.",19],[11,"bits","","Returns the raw value of the flags currently stored.",19],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",19],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",19],[11,"is_empty","","Returns `true` if no flags are currently stored.",19],[11,"is_all","","Returns `true` if all flags are currently set.",19],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",19],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",19],[11,"insert","","Inserts the specified flags in-place.",19],[11,"remove","","Removes the specified flags in-place.",19],[11,"toggle","","Toggles the specified flags in-place.",19],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",19],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",19],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",19],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",19],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",19],[6,"SigNum","nix::sys::signal",""],[17,"SIGEMT","",""],[11,"empty","","",20],[11,"add","","",20],[11,"remove","","",20],[11,"new","","",21],[0,"socket","nix::sys",""],[3,"in_addr","nix::sys::socket",""],[12,"s_addr","","",22],[3,"sockaddr","",""],[12,"sa_family","","",23],[12,"sa_data","","",23],[3,"sockaddr_storage","",""],[12,"ss_family","","",24],[12,"__ss_align","","",24],[12,"__ss_pad2","","",24],[3,"sockaddr_in","",""],[12,"sin_family","","",25],[12,"sin_port","","",25],[12,"sin_addr","","",25],[12,"sin_zero","","",25],[3,"sockaddr_in6","",""],[12,"sin6_family","","",26],[12,"sin6_port","","",26],[12,"sin6_flowinfo","","",26],[12,"sin6_addr","","",26],[12,"sin6_scope_id","","",26],[3,"sockaddr_un","",""],[12,"sun_family","","",27],[12,"sun_path","","",27],[6,"sa_family_t","",""],[3,"ip_mreq","",""],[12,"imr_multiaddr","","",28],[12,"imr_interface","","",28],[3,"SockFlag","",""],[3,"linger","",""],[12,"l_onoff","","",29],[12,"l_linger","","",29],[4,"SockAddr","","Represents a socket address"],[13,"IpV4","","",30],[13,"IpV6","","",30],[13,"Unix","","",30],[4,"SockLevel","",""],[13,"Socket","","",31],[13,"Tcp","","",31],[13,"Ip","","",31],[13,"Ipv6","","",31],[13,"Udp","","",31],[5,"socket","",""],[5,"listen","",""],[5,"bind","",""],[5,"accept","",""],[5,"accept4","",""],[5,"connect","",""],[5,"recvfrom","",""],[5,"sendto","",""],[5,"getsockopt","","Get the current value for the requested socket option"],[5,"setsockopt","","Sets the value for the requested socket option"],[5,"getpeername","",""],[5,"getsockname","",""],[11,"to_sock_addr","","",30],[11,"with_sock_addr","","",30],[11,"to_sock_addr","std::path","",32],[11,"to_sock_addr","std::net::addr","",33],[11,"from_sock_addr","","",33],[11,"from_sock_addr","std::path","",34],[0,"sockopt","nix::sys::socket",""],[3,"ReuseAddr","nix::sys::socket::sockopt",""],[3,"ReusePort","",""],[3,"TcpNoDelay","",""],[3,"Linger","",""],[3,"IpAddMembership","",""],[3,"IpMulticastTtl","",""],[11,"fmt","","",35],[6,"Get","",""],[6,"Set","",""],[11,"get","","",35],[11,"set","","",35],[11,"fmt","","",36],[6,"Get","",""],[6,"Set","",""],[11,"get","","",36],[11,"set","","",36],[11,"fmt","","",37],[6,"Get","",""],[6,"Set","",""],[11,"get","","",37],[11,"set","","",37],[11,"fmt","","",38],[6,"Get","",""],[6,"Set","",""],[11,"get","","",38],[11,"set","","",38],[11,"fmt","","",39],[6,"Get","",""],[6,"Set","",""],[11,"get","","",39],[11,"set","","",39],[11,"fmt","","",40],[6,"Get","",""],[6,"Set","",""],[11,"get","","",40],[11,"set","","",40],[17,"SOCK_NONBLOCK","nix::sys::socket",""],[17,"SOCK_CLOEXEC","",""],[8,"ToSockAddr","","A trait for values which can be converted or resolved to a SockAddr."],[10,"to_sock_addr","","Converts the value to a SockAddr",41],[11,"with_sock_addr","","Converts and yields the value as a SockAddr",41],[8,"FromSockAddr","","Convert from a socket address"],[10,"from_sock_addr","","",42],[8,"SockOpt","","Represents a socket option that can be accessed or set"],[16,"Get","nix::sys::socket::SockOpt","Type of `getsockopt` return value"],[16,"Set","","Type of value used to set the socket option. Used as the argument to\n`setsockopt`."],[11,"hash","nix::sys::socket","",43],[11,"cmp","","",43],[11,"partial_cmp","","",43],[11,"lt","","",43],[11,"le","","",43],[11,"gt","","",43],[11,"ge","","",43],[11,"clone","","",43],[11,"eq","","",43],[11,"ne","","",43],[11,"empty","","Returns an empty set of flags.",43],[11,"all","","Returns the set containing all flags.",43],[11,"bits","","Returns the raw value of the flags currently stored.",43],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",43],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",43],[11,"is_empty","","Returns `true` if no flags are currently stored.",43],[11,"is_all","","Returns `true` if all flags are currently set.",43],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",43],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",43],[11,"insert","","Inserts the specified flags in-place.",43],[11,"remove","","Removes the specified flags in-place.",43],[11,"toggle","","Toggles the specified flags in-place.",43],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",43],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",43],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",43],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",43],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",43],[11,"fmt","","",30],[0,"stat","nix::sys",""],[6,"dev_t","nix::sys::stat",""],[3,"FileStat","",""],[12,"st_dev","","",44],[12,"st_ino","","",44],[12,"st_nlink","","",44],[12,"st_mode","","",44],[12,"st_uid","","",44],[12,"st_gid","","",44],[12,"__pad0","","",44],[12,"st_rdev","","",44],[12,"st_size","","",44],[12,"st_blksize","","",44],[12,"st_blocks","","",44],[12,"st_atime","","",44],[12,"st_atime_nsec","","",44],[12,"st_mtime","","",44],[12,"st_mtime_nsec","","",44],[12,"st_ctime","","",44],[12,"st_ctime_nsec","","",44],[12,"__unused","","",44],[3,"SFlag","",""],[3,"Mode","",""],[5,"mknod","",""],[5,"mkdev","",""],[5,"umask","",""],[5,"stat","",""],[5,"fstat","",""],[17,"S_IFREG","",""],[17,"S_IFCHR","",""],[17,"S_IFBLK","",""],[17,"S_IFIFO","",""],[17,"S_IFSOCK","",""],[17,"S_IRWXU","",""],[17,"S_IRUSR","",""],[17,"S_IWUSR","",""],[17,"S_IXUSR","",""],[17,"S_IRWXG","",""],[17,"S_IRGRP","",""],[17,"S_IWGRP","",""],[17,"S_IXGRP","",""],[17,"S_IRWXO","",""],[17,"S_IROTH","",""],[17,"S_IWOTH","",""],[17,"S_IXOTH","",""],[17,"S_ISUID","",""],[17,"S_ISGID","",""],[17,"S_ISVTX","",""],[11,"hash","","",45],[11,"cmp","","",45],[11,"partial_cmp","","",45],[11,"lt","","",45],[11,"le","","",45],[11,"gt","","",45],[11,"ge","","",45],[11,"clone","","",45],[11,"eq","","",45],[11,"ne","","",45],[11,"empty","","Returns an empty set of flags.",45],[11,"all","","Returns the set containing all flags.",45],[11,"bits","","Returns the raw value of the flags currently stored.",45],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",45],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",45],[11,"is_empty","","Returns `true` if no flags are currently stored.",45],[11,"is_all","","Returns `true` if all flags are currently set.",45],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",45],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",45],[11,"insert","","Inserts the specified flags in-place.",45],[11,"remove","","Removes the specified flags in-place.",45],[11,"toggle","","Toggles the specified flags in-place.",45],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",45],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",45],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",45],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",45],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",45],[11,"hash","","",46],[11,"cmp","","",46],[11,"partial_cmp","","",46],[11,"lt","","",46],[11,"le","","",46],[11,"gt","","",46],[11,"ge","","",46],[11,"clone","","",46],[11,"eq","","",46],[11,"ne","","",46],[11,"empty","","Returns an empty set of flags.",46],[11,"all","","Returns the set containing all flags.",46],[11,"bits","","Returns the raw value of the flags currently stored.",46],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",46],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",46],[11,"is_empty","","Returns `true` if no flags are currently stored.",46],[11,"is_all","","Returns `true` if all flags are currently set.",46],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",46],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",46],[11,"insert","","Inserts the specified flags in-place.",46],[11,"remove","","Removes the specified flags in-place.",46],[11,"toggle","","Toggles the specified flags in-place.",46],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",46],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",46],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",46],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",46],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",46],[11,"fmt","","",45],[0,"termios","nix::sys",""],[3,"Termios","nix::sys::termios",""],[12,"c_iflag","","",47],[12,"c_oflag","","",47],[12,"c_cflag","","",47],[12,"c_lflag","","",47],[12,"c_line","","",47],[12,"c_cc","","",47],[12,"c_ispeed","","",47],[12,"c_ospeed","","",47],[3,"InputFlags","",""],[3,"OutputFlags","",""],[3,"ControlFlags","",""],[3,"LocalFlags","",""],[4,"SetArg","",""],[13,"TCSANOW","","",48],[13,"TCSADRAIN","","",48],[13,"TCSAFLUSH","","",48],[4,"FlushArg","",""],[13,"TCIFLUSH","","",49],[13,"TCOFLUSH","","",49],[13,"TCIOFLUSH","","",49],[4,"FlowArg","",""],[13,"TCOOFF","","",50],[13,"TCOON","","",50],[13,"TCIOFF","","",50],[13,"TCION","","",50],[5,"cfgetispeed","",""],[5,"cfgetospeed","",""],[5,"cfsetispeed","",""],[5,"cfsetospeed","",""],[5,"tcgetattr","",""],[5,"tcsetattr","",""],[5,"tcdrain","",""],[5,"tcflow","",""],[5,"tcflush","",""],[5,"tcsendbreak","",""],[11,"hash","","",51],[11,"cmp","","",51],[11,"partial_cmp","","",51],[11,"lt","","",51],[11,"le","","",51],[11,"gt","","",51],[11,"ge","","",51],[11,"clone","","",51],[11,"eq","","",51],[11,"ne","","",51],[11,"empty","","Returns an empty set of flags.",51],[11,"all","","Returns the set containing all flags.",51],[11,"bits","","Returns the raw value of the flags currently stored.",51],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",51],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",51],[11,"is_empty","","Returns `true` if no flags are currently stored.",51],[11,"is_all","","Returns `true` if all flags are currently set.",51],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",51],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",51],[11,"insert","","Inserts the specified flags in-place.",51],[11,"remove","","Removes the specified flags in-place.",51],[11,"toggle","","Toggles the specified flags in-place.",51],[11,"bitor","","Returns the union of the two sets of flags.",51],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",51],[11,"bitand","","Returns the intersection between the two sets of flags.",51],[11,"sub","","Returns the set difference of the two sets of flags.",51],[11,"not","","Returns the complement of this set of flags.",51],[11,"hash","","",52],[11,"cmp","","",52],[11,"partial_cmp","","",52],[11,"lt","","",52],[11,"le","","",52],[11,"gt","","",52],[11,"ge","","",52],[11,"clone","","",52],[11,"eq","","",52],[11,"ne","","",52],[11,"empty","","Returns an empty set of flags.",52],[11,"all","","Returns the set containing all flags.",52],[11,"bits","","Returns the raw value of the flags currently stored.",52],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",52],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",52],[11,"is_empty","","Returns `true` if no flags are currently stored.",52],[11,"is_all","","Returns `true` if all flags are currently set.",52],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",52],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",52],[11,"insert","","Inserts the specified flags in-place.",52],[11,"remove","","Removes the specified flags in-place.",52],[11,"toggle","","Toggles the specified flags in-place.",52],[11,"bitor","","Returns the union of the two sets of flags.",52],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",52],[11,"bitand","","Returns the intersection between the two sets of flags.",52],[11,"sub","","Returns the set difference of the two sets of flags.",52],[11,"not","","Returns the complement of this set of flags.",52],[11,"hash","","",53],[11,"cmp","","",53],[11,"partial_cmp","","",53],[11,"lt","","",53],[11,"le","","",53],[11,"gt","","",53],[11,"ge","","",53],[11,"clone","","",53],[11,"eq","","",53],[11,"ne","","",53],[11,"empty","","Returns an empty set of flags.",53],[11,"all","","Returns the set containing all flags.",53],[11,"bits","","Returns the raw value of the flags currently stored.",53],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",53],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",53],[11,"is_empty","","Returns `true` if no flags are currently stored.",53],[11,"is_all","","Returns `true` if all flags are currently set.",53],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",53],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",53],[11,"insert","","Inserts the specified flags in-place.",53],[11,"remove","","Removes the specified flags in-place.",53],[11,"toggle","","Toggles the specified flags in-place.",53],[11,"bitor","","Returns the union of the two sets of flags.",53],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",53],[11,"bitand","","Returns the intersection between the two sets of flags.",53],[11,"sub","","Returns the set difference of the two sets of flags.",53],[11,"not","","Returns the complement of this set of flags.",53],[11,"hash","","",54],[11,"cmp","","",54],[11,"partial_cmp","","",54],[11,"lt","","",54],[11,"le","","",54],[11,"gt","","",54],[11,"ge","","",54],[11,"clone","","",54],[11,"eq","","",54],[11,"ne","","",54],[11,"empty","","Returns an empty set of flags.",54],[11,"all","","Returns the set containing all flags.",54],[11,"bits","","Returns the raw value of the flags currently stored.",54],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",54],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",54],[11,"is_empty","","Returns `true` if no flags are currently stored.",54],[11,"is_all","","Returns `true` if all flags are currently set.",54],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",54],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",54],[11,"insert","","Inserts the specified flags in-place.",54],[11,"remove","","Removes the specified flags in-place.",54],[11,"toggle","","Toggles the specified flags in-place.",54],[11,"bitor","","Returns the union of the two sets of flags.",54],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",54],[11,"bitand","","Returns the intersection between the two sets of flags.",54],[11,"sub","","Returns the set difference of the two sets of flags.",54],[11,"not","","Returns the complement of this set of flags.",54],[6,"tcflag_t","",""],[6,"cc_t","",""],[6,"speed_t","",""],[17,"VEOF","",""],[17,"VEOL","",""],[17,"VEOL2","",""],[17,"VERASE","",""],[17,"VWERASE","",""],[17,"VKILL","",""],[17,"VREPRINT","",""],[17,"VINTR","",""],[17,"VQUIT","",""],[17,"VSUSP","",""],[17,"VSTART","",""],[17,"VSTOP","",""],[17,"VLNEXT","",""],[17,"VDISCARD","",""],[17,"VMIN","",""],[17,"VTIME","",""],[17,"NCCS","",""],[17,"IGNBRK","",""],[17,"BRKINT","",""],[17,"IGNPAR","",""],[17,"PARMRK","",""],[17,"INPCK","",""],[17,"ISTRIP","",""],[17,"INLCR","",""],[17,"IGNCR","",""],[17,"ICRNL","",""],[17,"IXON","",""],[17,"IXOFF","",""],[17,"IXANY","",""],[17,"IMAXBEL","",""],[17,"IUTF8","",""],[17,"OPOST","",""],[17,"ONLCR","",""],[17,"CSIZE","",""],[17,"CS5","",""],[17,"CS6","",""],[17,"CS7","",""],[17,"CS8","",""],[17,"CSTOPB","",""],[17,"CREAD","",""],[17,"PARENB","",""],[17,"PARODD","",""],[17,"HUPCL","",""],[17,"CLOCAL","",""],[17,"CRTSCTS","",""],[17,"ECHOKE","",""],[17,"ECHOE","",""],[17,"ECHOK","",""],[17,"ECHO","",""],[17,"ECHONL","",""],[17,"ECHOPRT","",""],[17,"ECHOCTL","",""],[17,"ISIG","",""],[17,"ICANON","",""],[17,"IEXTEN","",""],[17,"EXTPROC","",""],[17,"TOSTOP","",""],[17,"FLUSHO","",""],[17,"PENDIN","",""],[17,"NOFLSH","",""],[17,"NL0","",""],[17,"NL1","",""],[17,"TAB0","",""],[17,"TAB1","",""],[17,"TAB2","",""],[17,"TAB3","",""],[17,"CR0","",""],[17,"CR1","",""],[17,"CR2","",""],[17,"CR3","",""],[17,"FF0","",""],[17,"FF1","",""],[17,"BS0","",""],[17,"BS1","",""],[17,"VT0","",""],[17,"VT1","",""],[11,"hash","","",51],[11,"cmp","","",51],[11,"partial_cmp","","",51],[11,"lt","","",51],[11,"le","","",51],[11,"gt","","",51],[11,"ge","","",51],[11,"clone","","",51],[11,"eq","","",51],[11,"ne","","",51],[11,"empty","","Returns an empty set of flags.",51],[11,"all","","Returns the set containing all flags.",51],[11,"bits","","Returns the raw value of the flags currently stored.",51],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",51],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",51],[11,"is_empty","","Returns `true` if no flags are currently stored.",51],[11,"is_all","","Returns `true` if all flags are currently set.",51],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",51],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",51],[11,"insert","","Inserts the specified flags in-place.",51],[11,"remove","","Removes the specified flags in-place.",51],[11,"toggle","","Toggles the specified flags in-place.",51],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",51],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",51],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",51],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",51],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",51],[11,"hash","","",52],[11,"cmp","","",52],[11,"partial_cmp","","",52],[11,"lt","","",52],[11,"le","","",52],[11,"gt","","",52],[11,"ge","","",52],[11,"clone","","",52],[11,"eq","","",52],[11,"ne","","",52],[11,"empty","","Returns an empty set of flags.",52],[11,"all","","Returns the set containing all flags.",52],[11,"bits","","Returns the raw value of the flags currently stored.",52],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",52],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",52],[11,"is_empty","","Returns `true` if no flags are currently stored.",52],[11,"is_all","","Returns `true` if all flags are currently set.",52],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",52],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",52],[11,"insert","","Inserts the specified flags in-place.",52],[11,"remove","","Removes the specified flags in-place.",52],[11,"toggle","","Toggles the specified flags in-place.",52],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",52],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",52],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",52],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",52],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",52],[11,"hash","","",53],[11,"cmp","","",53],[11,"partial_cmp","","",53],[11,"lt","","",53],[11,"le","","",53],[11,"gt","","",53],[11,"ge","","",53],[11,"clone","","",53],[11,"eq","","",53],[11,"ne","","",53],[11,"empty","","Returns an empty set of flags.",53],[11,"all","","Returns the set containing all flags.",53],[11,"bits","","Returns the raw value of the flags currently stored.",53],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",53],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",53],[11,"is_empty","","Returns `true` if no flags are currently stored.",53],[11,"is_all","","Returns `true` if all flags are currently set.",53],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",53],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",53],[11,"insert","","Inserts the specified flags in-place.",53],[11,"remove","","Removes the specified flags in-place.",53],[11,"toggle","","Toggles the specified flags in-place.",53],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",53],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",53],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",53],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",53],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",53],[11,"hash","","",54],[11,"cmp","","",54],[11,"partial_cmp","","",54],[11,"lt","","",54],[11,"le","","",54],[11,"gt","","",54],[11,"ge","","",54],[11,"clone","","",54],[11,"eq","","",54],[11,"ne","","",54],[11,"empty","","Returns an empty set of flags.",54],[11,"all","","Returns the set containing all flags.",54],[11,"bits","","Returns the raw value of the flags currently stored.",54],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",54],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",54],[11,"is_empty","","Returns `true` if no flags are currently stored.",54],[11,"is_all","","Returns `true` if all flags are currently set.",54],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",54],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",54],[11,"insert","","Inserts the specified flags in-place.",54],[11,"remove","","Removes the specified flags in-place.",54],[11,"toggle","","Toggles the specified flags in-place.",54],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",54],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",54],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",54],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",54],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",54],[0,"utsname","nix::sys",""],[3,"UtsName","nix::sys::utsname",""],[5,"uname","",""],[11,"sysname","","",55],[11,"nodename","","",55],[11,"release","","",55],[11,"version","","",55],[11,"machine","","",55],[0,"wait","nix::sys",""],[3,"WaitPidFlag","nix::sys::wait",""],[4,"WaitStatus","",""],[13,"Exited","","",56],[13,"StillAlive","","",56],[5,"waitpid","",""],[17,"WNOHANG","",""],[11,"hash","","",57],[11,"cmp","","",57],[11,"partial_cmp","","",57],[11,"lt","","",57],[11,"le","","",57],[11,"gt","","",57],[11,"ge","","",57],[11,"clone","","",57],[11,"eq","","",57],[11,"ne","","",57],[11,"empty","","Returns an empty set of flags.",57],[11,"all","","Returns the set containing all flags.",57],[11,"bits","","Returns the raw value of the flags currently stored.",57],[11,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",57],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",57],[11,"is_empty","","Returns `true` if no flags are currently stored.",57],[11,"is_all","","Returns `true` if all flags are currently set.",57],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",57],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",57],[11,"insert","","Inserts the specified flags in-place.",57],[11,"remove","","Removes the specified flags in-place.",57],[11,"toggle","","Toggles the specified flags in-place.",57],[6,"Output","",""],[11,"bitor","","Returns the union of the two sets of flags.",57],[6,"Output","",""],[11,"bitxor","","Returns the left flags, but with all the right flags toggled.",57],[6,"Output","",""],[11,"bitand","","Returns the intersection between the two sets of flags.",57],[6,"Output","",""],[11,"sub","","Returns the set difference of the two sets of flags.",57],[6,"Output","",""],[11,"not","","Returns the complement of this set of flags.",57],[0,"mman","nix::sys",""],[5,"mlock","nix::sys::mman",""],[5,"munlock","",""],[5,"mmap","","Calls to mmap are inherently unsafe, so they must be made in an unsafe block. Typically\na higher-level abstraction will hide the unsafe interactions with the mmap'd region."],[5,"munmap","",""],[5,"madvise","",""],[5,"msync","",""],[5,"shm_open","",""],[5,"shm_unlink","",""],[6,"MmapFlag","",""],[6,"MmapProt","",""],[6,"MmapAdvise","",""],[6,"MmapSync","",""],[17,"MAP_SHARED","",""],[17,"MAP_PRIVATE","",""],[17,"MAP_FIXED","",""],[17,"MAP_FILE","",""],[17,"MAP_ANONYMOUS","",""],[17,"MAP_ANON","",""],[17,"MAP_32BIT","",""],[17,"MAP_GROWSDOWN","",""],[17,"MAP_DENYWRITE","",""],[17,"MAP_EXECUTABLE","",""],[17,"MAP_LOCKED","",""],[17,"MAP_NORESERVE","",""],[17,"MAP_POPULATE","",""],[17,"MAP_NONBLOCK","",""],[17,"MAP_STACK","",""],[17,"MAP_HUGETLB","",""],[17,"PROT_READ","",""],[17,"PROT_WRITE","",""],[17,"PROT_EXEC","",""],[17,"PROT_NONE","",""],[17,"PROT_GROWSDOWN","",""],[17,"PROT_GROWSUP","",""],[17,"MADV_NORMAL","",""],[17,"MADV_RANDOM","",""],[17,"MADV_SEQUENTIAL","",""],[17,"MADV_WILLNEED","",""],[17,"MADV_DONTNEED","",""],[17,"MADV_REMOVE","",""],[17,"MADV_DONTFORK","",""],[17,"MADV_DOFORK","",""],[17,"MADV_MERGEABLE","",""],[17,"MADV_UNMERGEABLE","",""],[17,"MADV_HUGEPAGE","",""],[17,"MADV_NOHUGEPAGE","",""],[17,"MADV_DONTDUMP","",""],[17,"MADV_DODUMP","",""],[17,"MADV_HWPOISON","",""],[17,"MS_ASYNC","",""],[17,"MS_SYNC","",""],[17,"MS_INVALIDATE","",""],[17,"MAP_FAILED","",""],[0,"uio","nix::sys",""],[3,"IoVec","nix::sys::uio",""],[5,"writev","",""],[5,"readv","",""],[11,"as_slice","","",58],[11,"from_slice","","",58],[11,"from_mut_slice","","",58],[0,"syscall","nix",""],[5,"syscall","nix::syscall",""],[6,"Syscall","",""],[7,"SYSPIVOTROOT","",""],[0,"unistd","nix",""],[4,"Fork","nix::unistd",""],[13,"Parent","","",59],[13,"Child","","",59],[5,"pivot_root","",""],[5,"fork","",""],[5,"dup","",""],[5,"dup2","",""],[5,"dup3","",""],[5,"chdir","",""],[5,"execve","",""],[5,"daemon","",""],[5,"sethostname","",""],[5,"gethostname","",""],[5,"close","",""],[5,"read","",""],[5,"write","",""],[5,"pipe","",""],[5,"pipe2","",""],[5,"ftruncate","",""],[5,"isatty","",""],[5,"unlink","",""],[11,"is_child","","",59],[11,"is_parent","","",59],[6,"NixResult","nix",""],[8,"NixPath","",""],[10,"with_nix_path","","",60],[11,"with_sock_addr","nix::sys::socket","Converts and yields the value as a SockAddr",41]],"paths":[[4,"c_void"],[4,"NixError"],[4,"Option"],[4,"Errno"],[3,"flock"],[4,"FcntlArg"],[3,"OFlag"],[3,"FdFlag"],[3,"MsFlags"],[3,"MntFlags"],[3,"CpuSet"],[3,"EpollEvent"],[4,"EpollOp"],[3,"EpollEventKind"],[3,"EventFdFlag"],[3,"Winsize"],[4,"IoctlArg"],[3,"siginfo"],[3,"sigaction"],[3,"SockFlag"],[3,"SigSet"],[3,"SigAction"],[3,"in_addr"],[3,"sockaddr"],[3,"sockaddr_storage"],[3,"sockaddr_in"],[3,"sockaddr_in6"],[3,"sockaddr_un"],[3,"ip_mreq"],[3,"linger"],[4,"SockAddr"],[4,"SockLevel"],[3,"Path"],[3,"SocketAddr"],[3,"PathBuf"],[3,"ReuseAddr"],[3,"ReusePort"],[3,"TcpNoDelay"],[3,"Linger"],[3,"IpAddMembership"],[3,"IpMulticastTtl"],[8,"ToSockAddr"],[8,"FromSockAddr"],[3,"SockFlag"],[3,"FileStat"],[3,"SFlag"],[3,"Mode"],[3,"Termios"],[4,"SetArg"],[4,"FlushArg"],[4,"FlowArg"],[3,"InputFlags"],[3,"OutputFlags"],[3,"ControlFlags"],[3,"LocalFlags"],[3,"UtsName"],[4,"WaitStatus"],[3,"WaitPidFlag"],[3,"IoVec"],[4,"Fork"],[8,"NixPath"]]};
initSearch(searchIndex);
